#!/usr/bin/env python3

# standard imports
import argparse
import asyncio
import json
import os
import random
import subprocess
import time


# Constants
DEFAULT_TIME_THRESHOLD = 23  # 1 day
DEFAULT_CHECK_INTERVAL = 1  # 1 hour

# Debugging
DEBUG = False

# Script name
SCRIPT_NAME =  os.path.basename(__file__)


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-n", "--netuids",
        type=int,
        nargs="+",
        required=True,
        help="The uids of the subnets to check.")

    parser.add_argument(
        "--time-threshold",
        type=float,
        default=DEFAULT_TIME_THRESHOLD,
        help="The threshold value in hours above which to manually set weights. "
             f"Default: {DEFAULT_TIME_THRESHOLD}")

    parser.add_argument(
        "--check-interval",
        type=float,
        default=DEFAULT_CHECK_INTERVAL,
        help="The interval in hours to check whether weights need to be "
             f"manually set. Default: {DEFAULT_CHECK_INTERVAL}")

    parser.add_argument(
        "--skip-discord-notify",
        action="store_false",
        dest="discord_notify",
        help="When specified, this will skip sending the notification to the "
             "discord monitor channel.")

    return parser.parse_args()


class TestWallet:
    _hotkey_addresses = {
        3: "5He5TL2hHRjU2R6MsPEwMUw4DTZnL9vszPwtCHag3vuDEjs3",
        20: "5ExaAP3ENz3bCJufTzWzs6J6dCWuhjjURT8AdZkQ5qA4As2o",
        45: "5DnNzmms8Pg7YekmHsDjJXKUMYeBG8ziM9nMj19pfiH5vs45",
        75: "5F9u6pymyXKHZWn1BSmimT9ux5LST9DRXiRHT8NQwTYpFs75",
    }

    class Hotkey:
        def __init__(self, hotkey_address):
            self.ss58_address = hotkey_address

    def __init__(self, name, hotkey):
        netuid = int(hotkey[2:])
        try:
            hotkey_address = self._hotkey_addresses[netuid]
        except KeyError:
            raise Exception(f"Can't test on subnet {netuid}.")
        self.hotkey = TestWallet.Hotkey(hotkey_address)


class SubnetWeightsChecker:
    _local_subtensors = [
        "cali",
        "candyland",
        "datacenter01",
        "la",
        "moonbase",
        "titan",
    ]

    _discord_monitor_url = (
        "https://discord.com/api/webhooks/1328849265765777468/"
        "yJg07DYWLJyiFZgZPaLGTmFEwiAu2JWW5osyjFVoqlMWT66JBbV9_FOcslvDdtibtcR0"
    )

    def __init__(self, options):
        self._netuids = options.netuids
        self._updated_threshold = round(options.time_threshold * 300)  # blocks
        self._check_interval = round(options.check_interval * 3600)  # seconds
        self._interval_blocks = round(self._check_interval / 12) # blocks
        self._discord_notify = options.discord_notify

        self._wallets = {}
        for netuid in self._netuids:
            self._wallets[netuid] = Wallet(  # TestWallet(
                name="RizzoNetwork", hotkey=f"rz{netuid:03d}",
            )

        random.seed()
        self._local_subtensor_index = random.randint(
            0, len(self._local_subtensors) - 1
        )
        self._expected_updated_values = dict(
            [(n, self._updated_threshold) for n in self._netuids]
        )

        self._run()

    def _log_info(self, message):
        bittensor.logging.info(message)

    def _log_error(self, message):
        bittensor.logging.error(message)

    def _log_warning(self, message):
        bittensor.logging.warning(message)

    def _log_debug(self, message):
        bittensor.logging.debug(message)

    def _run(self):
        while True:
            start_time = int(time.time())
            asyncio.run(self._async_run())

            elapsed_time = int(time.time()) - start_time
            sleep_interval = self._check_interval - elapsed_time
            if sleep_interval > 0:
                self._log_info("")
                self._log_info(f"Sleeping for {sleep_interval} seconds.")
                time.sleep(sleep_interval)
            else:
                # Shouldn't ever get here
                self._log_warning(
                    f"Elapsed time ({elapsed_time} seconds) is greater than "
                    f"check interval ({self._check_interval} seconds)."
                )

    async def _async_run(self):
        self._log_info("")
        self._log_info(
            "Checking updated values and determining whether to "
            "manually set weights."
        )
        self._log_info("")

        netuids = []
        for netuid in self._netuids:
            expected_updated = self._expected_updated_values[netuid]
            if expected_updated >= self._updated_threshold:
                netuids.append(netuid)
            else:
                self._expected_updated_values[netuid] += self._interval_blocks
                self._log_info(
                    f"Not checking subnet {netuid}. Expected updated value "
                    f"{expected_updated} < {self._updated_threshold}")

        if not netuids:
            return

        # Loop until we get a subtensor connection
        while True:
            self._local_subtensor_index = \
                (self._local_subtensor_index + 1) % len(self._local_subtensors)
            network_name = self._local_subtensors[self._local_subtensor_index]
            network = f"ws://subtensor-{network_name}.rizzo.network:9944"

            self._log_info("")
            self._log_info(f"Connecting to subtensor network: {network}")
            try:
                async with AsyncSubtensor(network=network) as subtensor:
                    await self._check_and_set_weights(subtensor, netuids)
                break
            except Exception as err:
                self._log_error("")
                self._log_error(f"Subtensor connection failed on '{network}'")
                self._log_error(f"{type(err).__name__}: {err}")
                self._log_error("")
                self._log_error("Rotating subtensors and trying again.")
                time.sleep(1)

    async def _check_and_set_weights(self, subtensor, netuids):
        # Get the block to pass to async calls so everything is in sync
        # and get the metagraph for each netuid.
        block = await subtensor.block
        metagraphs = await asyncio.gather(
            *[
                subtensor.metagraph(netuid=netuid, lite=False, block=block)
                for netuid in netuids
            ]
        )

        for i, netuid in enumerate(netuids):
            self._log_info("")
            self._log_info(f"Checking subnet {netuid}")

            metagraph = metagraphs[i]
            rizzo_hotkey = self._wallets[netuid].hotkey.ss58_address
            rizzo_uid = self._get_rizzo_uid(metagraph, rizzo_hotkey)
            if rizzo_uid is None:
                self._log_warning(
                    f"Rizzo validator is not running on subnet {netuid}."
                )
                continue

            rizzo_updated = int(
                metagraph.block - metagraph.last_update[rizzo_uid]
            )
            self._log_info(f"Rizzo Updated is {rizzo_updated} blocks.")

            # If the rizzo updated value is greater than the weights threshold
            # then manually set weights.
            if rizzo_updated >= self._updated_threshold:
                self._log_info(f"Updated value {rizzo_updated} "
                                f">= {self._updated_threshold}")
                self._log_info(
                    f"Manually setting weights on subnet {netuid}."
                )
                await self._set_weights(
                    subtensor, metagraph, netuid, rizzo_uid, rizzo_updated
                )
            else:
                self._expected_updated_values[netuid] = \
                    rizzo_updated + self._interval_blocks
                self._log_info(f"Updated value {rizzo_updated} "
                                f"< {self._updated_threshold}")
                self._log_info(f"Not setting weights on subnet {netuid}.")

    def _get_rizzo_uid(self, metagraph, rizzo_hotkey):
        try:
            uid = metagraph.hotkeys.index(rizzo_hotkey)
        except ValueError:
            self._log_warning(
                f"Rizzo hotkey {rizzo_hotkey} is not found on subnet {metagraph.netuid}."
            )
            return None

        if not metagraph.validator_permit[uid]:
            self._log_warning(
                f"Rizzo hotkey {rizzo_hotkey} does not have a validator permit "
                f"on subnet {metagraph.netuid}."
            )
            return None

        return uid

    async def _set_weights(
        self, subtensor, metagraph, netuid, rizzo_uid, rizzo_updated
    ):
        # Get weights.
        rizzo_weights = metagraph.weights[rizzo_uid]
        uids = metagraph.uids[rizzo_weights>0.0]
        weights = rizzo_weights[rizzo_weights>0.0]
        if uids.size == 0:
            self._log_info("Previous weights are all 0. Determining burn weights.")
            uids, weights = await self._get_burn_weights(subtensor, netuid)

        self._log_info("Setting the following weights:")
        self._log_info(f"    uids = {uids}")
        self._log_info(f"    weights = {weights}")

        # Get the weights version key.
        version_key_obj = await subtensor.query_subtensor(
            "WeightsVersionKey",
            params=[netuid],
        )
        version_key = version_key_obj.value
        self._log_debug(f"Subnet {netuid} Weights Version Key: {version_key}")

        # Set weights.
        success, message = await subtensor.set_weights(
            self._wallets[netuid],
            netuid,
            uids,
            weights,
            version_key=version_key,
            wait_for_inclusion=True,
            wait_for_finalization=True,
        )
        # success, message = (True, "Ignore.")
        if not success:
            self._log_error(
                f"Error setting weights on subnet {netuid}: {message}"
            )
            self._send_monitor_notification(
                f"Failed to manually set weights on subnet {netuid}: {message}"
            )
        else:
            self._log_info(f"Weights successfully set on subnet {netuid}.")
            self._send_monitor_notification(
                f"Manually set weights on subnet {netuid} - Updated value was {rizzo_updated}"
            )

        self._expected_updated_values[netuid] = self._interval_blocks

    async def _get_burn_weights(self, subtensor, netuid):
        # Get the subtensor owner hotkey
        owner_hotkey = await subtensor.query_subtensor(
            "SubnetOwnerHotkey",
            params=[netuid],
        )
        self._log_debug(f"Subnet {netuid} Owner Hotkey: {owner_hotkey}")

        # Get the UID of this hotkey
        owner_uid = await subtensor.get_uid_for_hotkey_on_subnet(
            hotkey_ss58=owner_hotkey,
            netuid=netuid,
        )
        self._log_debug(f"Subnet {netuid} Owner UID: {owner_uid}")

        uids = [owner_uid]
        weights = [1.0]

        return uids, weights

    def _send_monitor_notification(self, message):
        if not self._discord_notify:
            self._log_info("Not sending discord monitor notification.")
            return

        text = f"{SCRIPT_NAME}: " + message
        payload = json.dumps({"content": text})
        monitor_cmd = [
            "curl", "-H", "Content-Type: application/json",
            "-d", payload, self._discord_monitor_url
        ]
        monitor_cmd_str = " ".join(monitor_cmd)
        self._log_info(f"Running command: '{monitor_cmd_str}'")
        try:
            subprocess.run(monitor_cmd, check=True)
        except subprocess.CalledProcessError as exc:
            self._log_error("Failed to send discord monitor notification.")
            self._log_error(
                f"'{monitor_cmd_str}' command failed with error {exc}")
        else:
            self._log_info("Discord monitor notification successfully sent.")


def main(options):
    if DEBUG:
        bittensor.logging.enable_debug()
    else:
        bittensor.logging.enable_info()

    bittensor.logging.info("")
    bittensor.logging.info(f"Starting {SCRIPT_NAME}")
    bittensor.logging.info("")

    SubnetWeightsChecker(options)


if __name__ == "__main__":
    options = parse_args()

    # Importing bittensor here suppresses the --help info
    import bittensor
    from bittensor.core.async_subtensor import AsyncSubtensor
    from bittensor_wallet import Wallet

    main(options)
