#!/usr/bin/env python3

# bittensor import
import bittensor

# standard imports
import argparse
from concurrent.futures import ThreadPoolExecutor
import json
import os
import pty
import re
import subprocess
import tempfile
import time


def _parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-n", "--netuid",
        type=int,
        required=True,
        help="The uid of the subnet.")
    
    parser.add_argument(
        "--restart-script",
        required=True,
        help="The restart script path.")

    parser.add_argument(
        "--restart-venv",
        required=True,
        help="The restart venv path.")

    parser.add_argument(
        "--pm2-process",
        required=True,
        help="Restart the validator based on log patterns. The value passed "
             "to this arg is the name of the pm2 process to monitor.")

    parser.add_argument(
        "--output-log-threshold",
        type=float,
        default=20,
        help="The time in minutes after which to restart the process if the "
             "pm2 out log file hasn't updated.")

    parser.add_argument(
        "--updated-threshold",
        type=float,
        default=3,
        help="The multiplier on the subnet's tempo value used to calculate "
             "the Updated threshold value for which to restart the validator. "
             "For example, if this value is 3, then the validator will be "
             "restarted if its Updated value is greater than "
             "(subnet_tempo * 3).")

    return parser.parse_args()


class ValidatorChecker:
    def __init__(self, options):
        self._netuid = options.netuid
        self._restarter = options.restarter_class(self, options)

        self._init_setup(options)

        self._run()
    
    def _log_info(self, message):
        bittensor.logging.info(f"{self.log_prefix}: {message}")

    def _log_error(self, message):
        bittensor.logging.error(f"{self.log_prefix}: {message}")

    def _init_setup(self, options):
        raise NotImplementedError("Must be implemented in subclasses.")

    def _run(self):
        raise NotImplementedError("Must be implemented in subclasses.")


class ValidatorCheckerUpdated(ValidatorChecker):
    log_prefix = "CHECK UPDATED"
    _rizzo_hotkey = "5F2CsUDVbRbVMXTh9fAzF9GacjVX7UapvRxidrxe7z8BYckQ"

    def _init_setup(self, options):
        self._updated_threshold = options.updated_threshold
        # Start false in case this is added after a manual restart
        # but before it started setting weights again
        # TODO - Fix this whole logic
        self._check_for_restart = False

        self._subtensor = bittensor.subtensor()
        self._subnet_tempo = self._subtensor.get_subnet_hyperparameters(
            self._netuid).tempo
        self._restart_threshold = self._subnet_tempo * self._updated_threshold

        metagraph = self._subtensor.metagraph(netuid=self._netuid)
        self._rizzo_uid = metagraph.hotkeys.index(self._rizzo_hotkey)

    def _run(self):
        self._log_info("")
        self._log_info("Checking for high Updated values.")
        self._log_info("")

        while True:
            rizzo_updated = self._subtensor.blocks_since_last_update(
                    netuid=self._netuid, uid=self._rizzo_uid)
            self._log_info("")
            self._log_info(f"Rizzo Updated is {rizzo_updated} blocks.")

            if self._check_for_restart:
                # If the rizzo updated value is greater than the restart threshold
                # the do a restart and set _check_for_restart to False.
                self._log_info("Updated value check for restart is True.")
                if rizzo_updated >= self._restart_threshold:
                    self._log_info(f"Updated value {rizzo_updated} "
                                   f">= {self._restart_threshold}")
                    self._restarter.do_restart()
                    self._log_info("Setting check for restart to False.")
                    self._check_for_restart = False
                else:
                    self._log_info(f"Updated value {rizzo_updated} "
                                   f"< {self._restart_threshold}")
                    self._log_info("Doing nothing.")
            else:
                # If the rizzo updated value is less than the restart threshold
                # then set _check_for_restart.
                self._log_info("Updated value Check for restart is False.")
                if rizzo_updated < self._restart_threshold:
                    self._log_info(f"Updated value {rizzo_updated} "
                                   f"< {self._restart_threshold}")
                    self._log_info("Setting check for restart to True.")
                    self._check_for_restart = True
                else:
                    self._log_info(f"Updated value {rizzo_updated} "
                                   f">= {self._restart_threshold}")
                    self._log_info("Doing nothing.")

            seconds_until_threshold = \
                (self._restart_threshold - rizzo_updated) * 12
            sleep_interval = (seconds_until_threshold
                              if seconds_until_threshold > 0
                              else self._subnet_tempo * 12)
            self._log_info(f"Sleeping for {sleep_interval} seconds.")
            time.sleep(sleep_interval)


class ValidatorCheckerPm2LogErrors(ValidatorChecker):
    log_prefix = "CHECK LOG ERRORS"
    _generic_patterns = [r"\[Errno 32\] Broken pipe"]
    _subnet_patterns = []

    def _init_setup(self, options):
        self._pm2_process = options.pm2_process

    def _run(self):
        self._log_info("")
        self._log_info("Checking for log patterns.")
        self._log_info("")

        log_regexes = []
        for log_pattern in self._generic_patterns + self._subnet_patterns:
            log_regexes.append(re.compile(log_pattern))
        command = ["pm2", "log", self._pm2_process, "--raw"]
        command_str = " ".join(command)

        while True:
            self._log_info(f"Launching \"{command_str}\" process")

            mfd, sfd = pty.openpty()
            process = subprocess.Popen(
                command, stdout=sfd, stderr=subprocess.STDOUT)
            os.close(sfd)
            master = os.fdopen(mfd)
            while True:
                try:
                    line = master.readline()
                except:
                    # The process exited.
                    self._log_info("Process exited")
                    break
                else:
                    for log_regex in log_regexes:
                        if log_regex.search(line):
                            self._log_info(
                                "Log line matches a restart pattern:\n"
                                f"{line}\n")
                            self._restarter.do_restart()
                            break
            self._log_info("Killing process")
            process.kill()
            master.close()
            sleep_time = 15
            self._log_info(f"Sleeping {sleep_time} seconds")
            time.sleep(sleep_time)


class ValidatorCheckerPm2LogErrorsSn34(ValidatorCheckerPm2LogErrors):
    _subnet_patterns = [r"Handshake status 502 Bad Gateway"]


class ValidatorCheckerPm2LogErrorsSn18(ValidatorCheckerPm2LogErrors):
    _subnet_patterns = [r"asyncio.exceptions.CancelledError"]


class ValidatorCheckerPm2StoppedLogs(ValidatorChecker):
    log_prefix = "CHECK LOGS STOPPED"

    def _init_setup(self, options):
        self._pm2_process = options.pm2_process
        self._restart_threshold = options.output_log_threshold * 60

    def _run(self):
        self._log_info("")
        self._log_info("Checking for stopped logs.")
        self._log_info("")

        process = subprocess.run(["pm2", "jlist"], stdout=subprocess.PIPE)
        pm2_output = json.loads(process.stdout)
        for pm2_process in pm2_output:
            if pm2_process["name"] == self._pm2_process:
                log_file =  pm2_process['pm2_env']['pm_out_log_path']
                break

        self._log_info(f"Log file: {log_file}")

        while True:
            log_file_mtime = int(os.path.getmtime(log_file))
            current_time = int(time.time())
            log_file_ctime = time.ctime(log_file_mtime)
            current_ctime = time.ctime(current_time)
            self._log_info("")
            self._log_info(f"Log file last modified: {log_file_ctime}")
            self._log_info(f"Current time: {current_ctime}")

            time_diff = current_time - log_file_mtime
            if time_diff >= self._restart_threshold:
                self._log_info(f"Time difference {time_diff} seconds "
                               f">= {self._restart_threshold} seconds")
                self._restarter.do_restart()
            else:
                self._log_info(f"Time difference {time_diff} seconds "
                               f"< {self._restart_threshold} seconds")
                self._log_info("Doing nothing.")

            seconds_until_threshold = \
                (self._restart_threshold - time_diff)
            sleep_interval = (seconds_until_threshold
                              if seconds_until_threshold > 0
                              else self._restart_threshold)
            self._log_info(f"Sleeping for {sleep_interval} seconds.")
            time.sleep(sleep_interval)


class ValidatorRestarterRsnScript:
    _discord_monitor_url = (
    "https://discord.com/api/webhooks/1307044814348488704/"
    "uYEDTqa89CI-NPau5zDyET_JTGt1r2j1u3ARvSEVCKP7-nnOfvCoUoEKwdZCLoiXKsjV"
    )

    def __init__(self, checker_obj, options):
        self._checker_obj = checker_obj
        self._netuid = options.netuid
        self._restart_script =  os.path.expanduser(options.restart_script)
        self._restart_venv = (
            os.path.expanduser(options.restart_venv)
            if options.restart_venv else None)
        self._restart_dir = os.path.expanduser(
            f"~/restart_scripts_sn{options.netuid}")
        os.makedirs(self._restart_dir, exist_ok=True)
        for restart_file in os.listdir(self._restart_dir):
            restart_file_path = os.path.join(self._restart_dir, restart_file)
            if os.path.isfile(restart_file_path):
                os.unlink(restart_file_path)

    def _log_info(self, message):
        bittensor.logging.info(f"{self._checker_obj.log_prefix}: {message}")

    def _log_error(self, message):
        bittensor.logging.error(f"{self._checker_obj.log_prefix}: {message}")

    def do_restart(self):
        # TODO: acquire threading lock
        self._do_restart()

    def _do_restart(self):
        script_name =  os.path.basename(__file__)

        self._log_info(f"Restarting subnet {self._netuid}.")
        self._log_info(f"Running script: {self._restart_script}")
        if self._restart_venv:
            self._log_info(f"Running in venv: {self._restart_venv}")

        fd, restart_script = tempfile.mkstemp(dir=self._restart_dir,
            prefix = f"restart_{self._netuid}_", suffix=".sh")
        os.close(fd)
        os.chmod(restart_script, 0o700)

        self._log_info(f"Packaging venv and script into {restart_script}")
        with open(restart_script, "w") as fd:
            # TODO - This could probably be cleaned up a little
            if self._restart_venv:
                venv_activate = os.path.join(self._restart_venv, "bin/activate")
                fd.write("#!/bin/bash\n"
                            "\n"
                            "deactivate\n"
                            f"source {venv_activate}\n"
                            f"{self._restart_script}\n")
            else:
                fd.write("#!/bin/bash\n"
                        "\n"
                        "deactivate\n"
                        f"{self._restart_script}\n")
        restart_cmd = [restart_script]

        restart_cmd_str = " ".join(restart_cmd)
        self._log_info(f"Running command: '{restart_cmd_str}'")
        process = subprocess.run(restart_cmd)

        if process.returncode:
            self._log_error(
                f"'{restart_cmd_str}' command failed with return code "
                f"{process.returncode}.")
            self._send_monitor_notification(
                f"{script_name}: Failed to restart subnet {self._netuid}")
            return False
        
        os.unlink(restart_script)
        self._log_info(f"Subnet '{self._netuid}' successfully restarted.")
        self._send_monitor_notification(
            f"{script_name}: Successfully restarted on subnet {self._netuid}")

        return True

    def _send_monitor_notification(self, message):
        payload = json.dumps({"content": message})
        monitor_cmd = [
            "curl", "-H", "Content-Type: application/json",
            "-d", payload, self._discord_monitor_url
        ]
        monitor_cmd_str = " ".join(monitor_cmd)
        self._log_info(f"Running command: '{monitor_cmd_str}'")
        process = subprocess.run(monitor_cmd)

        if process.returncode:
            self._log_error(
                f"'{monitor_cmd_str}' command failed with return code "
                f"{process.returncode}.")
        else:
            self._log_info("Monitor notification successfully sent.")


# TODO - Implement this
class ValidatorRestarterDocker:
    pass


# TODO - This can be done better
PM2_LOGS_VALIDATORS_DICT = {
    34: ValidatorCheckerPm2LogErrorsSn34,
    18: ValidatorCheckerPm2LogErrorsSn18
}


def _run_checker(checker_class, options):
    checker_class(options)


def main():
    bittensor.logging.enable_debug()
    options = _parse_args()

    sleep_time = 15
    script_name =  os.path.basename(__file__)
    bittensor.logging.info("")
    bittensor.logging.info(f"Starting {script_name} on subnet {options.netuid}")
    bittensor.logging.info(f"Sleeping {sleep_time} seconds in case the "
                            "validator process is just starting.")
    bittensor.logging.info("")
    time.sleep(sleep_time)

    log_checker_class = PM2_LOGS_VALIDATORS_DICT.get(
        options.netuid, ValidatorCheckerPm2LogErrors)

    options.restarter_class = ValidatorRestarterRsnScript
    with ThreadPoolExecutor(max_workers=3) as executor:
        bittensor.logging.info("")
        bittensor.logging.info("================================")
        bittensor.logging.info("Running Updated value checker.")
        bittensor.logging.info("================================")
        bittensor.logging.info("")
        executor.submit(_run_checker, ValidatorCheckerUpdated, options)

        bittensor.logging.info(f"Sleeping {sleep_time} seconds before "
                                "starting the next one.")
        time.sleep(sleep_time)

        bittensor.logging.info("")
        bittensor.logging.info("================================")
        bittensor.logging.info("Running log errors checker.")
        bittensor.logging.info("================================")
        bittensor.logging.info("")
        executor.submit(_run_checker, log_checker_class, options)

        bittensor.logging.info(f"Sleeping {sleep_time} seconds before "
                                "starting the next one.")
        time.sleep(sleep_time)

        bittensor.logging.info("")
        bittensor.logging.info("================================")
        bittensor.logging.info("Running stopped logs checker.")
        bittensor.logging.info("================================")
        bittensor.logging.info("")
        executor.submit(_run_checker, ValidatorCheckerPm2StoppedLogs, options)


if __name__ == "__main__":
    main()
