#!/usr/bin/env python3

# standard imports
import argparse
import asyncio


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-n",
        type=int,
        dest="netuids",
        nargs="+",
        help="The uids of the subnets to check. If not specified then all subnets are checked.")

    return parser.parse_args()


async def main():
    import bittensor

    args = parse_args()

    print("")
    print("Subnets with multiple mechanisms")
    print("=================================")

    async with bittensor.AsyncSubtensor() as subtensor:
        if args.netuids:
            netuids = args.netuids
        else:
            netuids = await subtensor.get_all_subnets_netuid()
            netuids = netuids[1:]

        mechs_list = await asyncio.gather(
            *[
                subtensor.get_mechanism_count(netuid)
                for netuid in netuids
            ]
        )

        # TODO: Only use asyncio.gather to get the emission splits if the
        # number of subnets using multiple mechanisms gets large.
        # emission_list = await asyncio.gather(
        #     *[
        #         subtensor.get_mechanism_emission_split(netuid)
        #         for netuid in netuids
        #     ]
        # )

        for netuid, mechs in zip(netuids, mechs_list):
            if mechs != 1:
                emission = await subtensor.get_mechanism_emission_split(netuid)
                emission = ", ".join([f"{e}%" for e in emission])
                netuid = f"{netuid}:"
                print(f"{netuid:<4} {mechs} ({emission})")

    print("")


if __name__ == "__main__":
    asyncio.run(main())
