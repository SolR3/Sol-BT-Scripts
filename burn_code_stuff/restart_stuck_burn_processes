#!/usr/bin/env python3

# standard imports
import argparse
import json
import os
import re
import shlex
import subprocess
import time


# Constants
# TODO: Change this to 400 once all burn subnets are on the latest code
# that sets weights every epoch instead of every two epochs.
STOPPED_LOGS_THRESHOLD_BLOCKS = 400  # Two epochs plus 40 blocks padding
WAIT_BLOCKS = 180  # Half an epoch
PROCESS_LOCATION = "Super5"
DISCORD_MONITOR_URL = (
    "https://discord.com/api/webhooks/1328849265765777468/"
    "yJg07DYWLJyiFZgZPaLGTmFEwiAu2JWW5osyjFVoqlMWT66JBbV9_FOcslvDdtibtcR0"
)


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--skip-discord-notify",
        action="store_false",
        dest="discord_notify",
        help="When specified, this will skip sending the notification to the "
             "discord monitor channel.")

    return parser.parse_args()


class BurnProcessChecker: 
    def __init__(self, discord_notify):
        # Converting blocks to seconds
        self._discord_notify = discord_notify

        self._run()

    def _log_info(self, message):
        print(f"INFO - {message}")

    def _log_error(self, message):
        print(f"ERROR - {message}")

    def _run(self):
        restart_threshold = STOPPED_LOGS_THRESHOLD_BLOCKS * 12  # In seconds
        wait_time = WAIT_BLOCKS * 12  # In seconds
        burn_process_regex = re.compile(r"^burn_sn(?P<netuid>\d+)$")

        while True:
            self._log_info("")
            self._log_info("")
            self._log_info("Checking for stopped burn process logs.")

            process = subprocess.run(["pm2", "jlist"], stdout=subprocess.PIPE)
            pm2_output = json.loads(process.stdout)
            for pm2_process in sorted(pm2_output, key=lambda p: p["name"]):
                pm2_name = pm2_process["name"]
                try:
                    netuid = burn_process_regex.match(pm2_name).group("netuid")
                except AttributeError:
                    continue

                out_log_file = pm2_process["pm2_env"]["pm_out_log_path"]
                error_log_file = pm2_process["pm2_env"]["pm_err_log_path"]

                self._log_info("")
                self._log_info(f"Pm2 process: {pm2_name}")
                self._log_info("")
                self._log_info(f"Out Log file: {out_log_file}")
                self._log_info(f"Error Log file: {error_log_file}")

                out_log_file_mtime = int(os.path.getmtime(out_log_file))
                error_log_file_mtime = int(os.path.getmtime(error_log_file))
                current_time = int(time.time())
                out_log_file_ctime = time.ctime(out_log_file_mtime)
                error_log_file_ctime = time.ctime(error_log_file_mtime)
                current_ctime = time.ctime(current_time)
                self._log_info("")
                self._log_info(f"Out Log file last modified: {out_log_file_ctime}")
                self._log_info(f"Error Log file last modified: {error_log_file_ctime}")
                self._log_info(f"Current time: {current_ctime}")

                time_diff = current_time - max(out_log_file_mtime, error_log_file_mtime)
                if time_diff >= restart_threshold:
                    self._log_info(f"Time difference {time_diff} seconds "
                                f">= {restart_threshold} seconds")
                    log_blocks = time_diff // 12
                    msg = f"No log output in {log_blocks} blocks."
                    self._log_error(msg)
                    self._do_restart(pm2_name, netuid, msg)
                else:
                    self._log_info(f"Time difference {time_diff} seconds "
                                f"< {restart_threshold} seconds")
                    self._log_info("Doing nothing.")

            self._log_info(f"Sleeping for {wait_time} seconds.")
            time.sleep(wait_time)

    def _do_restart(self, pm2_name, netuid, msg):
        self._log_info(f"Restarting {pm2_name} pm2 process.")
        try:
            subprocess.run(["pm2", "restart", pm2_name], check=True)
        except subprocess.CalledProcessError as exc:
            self._log_error(f"Restart failed with error: {exc}")
            self._send_monitor_notification(
                f"Failed to restart burn code for subnet {netuid} on "
                f"{PROCESS_LOCATION} - {msg}"
            )
            return False

        self._log_info("Successfully restarted.")
        self._send_monitor_notification(
            f"Successfully restarted burn code for subnet {netuid} on "
            f"{PROCESS_LOCATION} - {msg}"
        )
        return True

    def _send_monitor_notification(self, message):
        if not self._discord_notify:
            self._log_info("Not sending discord monitor notification.")
            return

        payload = json.dumps({"content": message})
        monitor_cmd = [
            "curl", "-H", "Content-Type: application/json",
            "-d", payload, DISCORD_MONITOR_URL
        ]
        monitor_cmd_str = shlex.join(monitor_cmd)
        self._log_info(f"Running command: '{monitor_cmd_str}'")
        try:
            subprocess.run(monitor_cmd, check=True)
        except subprocess.CalledProcessError as exc:
            self._log_error("Failed to send discord monitor notification.")
            self._log_error(
                f"'{monitor_cmd_str}' command failed with error {exc}")
        else:
            self._log_info("Discord monitor notification successfully sent.")


def main(options):
    script_name =  os.path.basename(__file__)
    print(f"\nStarting {script_name}.\n")

    BurnProcessChecker(options.discord_notify)

if __name__ == "__main__":
    options = parse_args()
    main(options)
